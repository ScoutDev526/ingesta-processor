package es.ing.icenterprise.arthur.adapters.outbound.persistence;

import es.ing.icenterprise.arthur.core.domain.model.Action;
import es.ing.icenterprise.arthur.core.domain.model.DatabaseMapping;
import es.ing.icenterprise.arthur.core.ports.outbound.PersistencePort;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.sql.Timestamp;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

@Component
public class JdbcPersistenceAdapter implements PersistencePort {

    private static final Logger log = LoggerFactory.getLogger(JdbcPersistenceAdapter.class);

    private final JdbcTemplate jdbcTemplate;

    public JdbcPersistenceAdapter(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public void insertData(List<Action> data, List<DatabaseMapping> mappings, Map<String, Object> parameters) {
        String tableName = (String) parameters.getOrDefault("tableName", "ingesta_data");
        log.info("Inserting {} records into table: {} using {} mappings", data.size(), tableName, mappings.size());

        if (data.isEmpty() || mappings.isEmpty()) return;

        // Build column list from mappings
        List<String> dbColumns = mappings.stream()
                .map(DatabaseMapping::dbColumn)
                .toList();

        // Build placeholders: ? for normal/concat, function call for auto-generated
        List<String> placeholders = mappings.stream()
                .map(this::buildPlaceholder)
                .toList();

        String sql = String.format("INSERT INTO %s (%s) VALUES (%s)",
                tableName,
                String.join(", ", dbColumns),
                String.join(", ", placeholders));

        log.debug("Generated SQL: {}", sql);

        // Build batch args: only include ? params (skip DB-side auto-generated)
        Instant batchTimestamp = Instant.now();

        List<Object[]> batchArgs = data.stream()
                .map(action -> buildRowArgs(action, mappings, batchTimestamp))
                .toList();

        jdbcTemplate.batchUpdate(sql, batchArgs);
        log.info("Successfully inserted {} records into {}", data.size(), tableName);
    }

    @Override
    public Object check(Object data, Map<String, Object> parameters) {
        String query = (String) parameters.getOrDefault("query", "SELECT 1");
        log.info("Executing check query: {}", query);
        return jdbcTemplate.queryForObject(query, Object.class);
    }

    @Override
    public void truncate(Map<String, Object> parameters) {
        String tableName = (String) parameters.getOrDefault("tableName", "ingesta_data");
        log.info("Truncating table: {}", tableName);
        jdbcTemplate.execute("TRUNCATE TABLE " + tableName);
    }

    /**
     * Builds the placeholder for a mapping in the VALUES clause.
     * Normal and concatenated fields use ?, auto-generated use ? too
     * (we resolve values in Java, not DB functions, for portability).
     */
    private String buildPlaceholder(DatabaseMapping mapping) {
        return "?";
    }

    /**
     * Builds the argument array for a single row based on the mappings.
     */
    private Object[] buildRowArgs(Action action, List<DatabaseMapping> mappings, Instant batchTimestamp) {
        return mappings.stream()
                .map(mapping -> resolveValue(action, mapping, batchTimestamp))
                .toArray();
    }

    /**
     * Resolves the value for a single mapping from an Action row.
     */
    private Object resolveValue(Action action, DatabaseMapping mapping, Instant batchTimestamp) {
        if (mapping.isAutoGenerated()) {
            return resolveAutoGenerated(mapping, batchTimestamp);
        }

        if (mapping.isConcatenated()) {
            return resolveConcatenated(action, mapping);
        }

        // Normal mapping: get value from Excel by original header name
        return action.get(mapping.excelColumn());
    }

    private Object resolveAutoGenerated(DatabaseMapping mapping, Instant batchTimestamp) {
        return switch (mapping.autoGenerate().toUpperCase()) {
            case "TIMESTAMP" -> Timestamp.from(batchTimestamp);
            case "UUID" -> UUID.randomUUID().toString();
            default -> {
                log.warn("Unknown autoGenerate type: {}", mapping.autoGenerate());
                yield null;
            }
        };
    }

    private Object resolveConcatenated(Action action, DatabaseMapping mapping) {
        return mapping.concatenate().stream()
                .map(col -> {
                    Object val = action.get(col);
                    return val != null ? val.toString() : "";
                })
                .filter(s -> !s.isBlank())
                .collect(Collectors.joining(mapping.separator()));
    }
}
