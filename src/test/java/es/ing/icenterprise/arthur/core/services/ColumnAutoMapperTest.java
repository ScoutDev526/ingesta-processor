package es.ing.icenterprise.arthur.core.services;

import es.ing.icenterprise.arthur.core.domain.model.DatabaseMapping;
import es.ing.icenterprise.arthur.core.ports.outbound.TableMetadataPort;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class ColumnAutoMapperTest {

    @Mock
    private TableMetadataPort tableMetadataPort;

    private ColumnAutoMapper autoMapper;

    @BeforeEach
    void setUp() {
        autoMapper = new ColumnAutoMapper(tableMetadataPort);
    }

    @Test
    @DisplayName("Should auto-map Excel headers to DB columns by normalization")
    void shouldAutoMapByNormalization() {
        // DB columns
        when(tableMetadataPort.getColumnNames("T_VENTAS", null))
                .thenReturn(List.of("NOMBRE_PRODUCTO", "REGION", "PRECIO", "FECHA_INGESTA"));

        // Excel headers
        List<String> excelHeaders = List.of("Nombre Producto", "Región", "Precio", "Notas internas");

        List<DatabaseMapping> result = autoMapper.resolve(excelHeaders, "T_VENTAS", null, List.of());

        // Should map 3 columns (Notas internas has no DB match, FECHA_INGESTA has no Excel match)
        assertThat(result).hasSize(3);
        assertThat(result).extracting(DatabaseMapping::dbColumn)
                .containsExactly("NOMBRE_PRODUCTO", "REGION", "PRECIO");
        assertThat(result).extracting(DatabaseMapping::excelColumn)
                .containsExactly("Nombre Producto", "Región", "Precio");
    }

    @Test
    @DisplayName("Should merge explicit mappings with auto-mapped")
    void shouldMergeExplicitMappings() {
        when(tableMetadataPort.getColumnNames("T_VENTAS", null))
                .thenReturn(List.of("NOMBRE_PRODUCTO", "REGION", "PRECIO", "FECHA_INGESTA", "CODIGO_REF"));

        List<String> excelHeaders = List.of("Nombre Producto", "Región", "Precio");

        // Explicit: FECHA_INGESTA auto-generated, CODIGO_REF concatenated
        List<DatabaseMapping> explicit = List.of(
                new DatabaseMapping(null, "FECHA_INGESTA", "TIMESTAMP", null, ""),
                new DatabaseMapping(null, "CODIGO_REF", null, List.of("Región", "Nombre Producto"), "-")
        );

        List<DatabaseMapping> result = autoMapper.resolve(excelHeaders, "T_VENTAS", null, explicit);

        // 3 auto + 2 explicit = 5
        assertThat(result).hasSize(5);

        // Verify auto-mapped
        assertThat(result.stream().filter(DatabaseMapping::isNormalField).toList()).hasSize(3);

        // Verify explicit
        assertThat(result.stream().filter(DatabaseMapping::isAutoGenerated).toList()).hasSize(1);
        assertThat(result.stream().filter(DatabaseMapping::isConcatenated).toList()).hasSize(1);
    }

    @Test
    @DisplayName("Explicit mapping should override auto-map for same DB column")
    void explicitShouldOverrideAutoMap() {
        when(tableMetadataPort.getColumnNames("T_VENTAS", null))
                .thenReturn(List.of("REGION", "PRECIO"));

        List<String> excelHeaders = List.of("Región", "Precio");

        // Explicit override for REGION: use a different Excel column name
        List<DatabaseMapping> explicit = List.of(
                new DatabaseMapping("Región", "REGION")
        );

        List<DatabaseMapping> result = autoMapper.resolve(excelHeaders, "T_VENTAS", null, explicit);

        // REGION only once (explicit), PRECIO auto-mapped
        long regionCount = result.stream()
                .filter(m -> "REGION".equals(m.dbColumn()))
                .count();
        assertThat(regionCount).isEqualTo(1);
        assertThat(result).hasSize(2);
    }

    @Test
    @DisplayName("Should return only explicit mappings when Excel headers are empty")
    void shouldHandleEmptyExcelHeaders() {
        when(tableMetadataPort.getColumnNames("T_VENTAS", null))
                .thenReturn(List.of("NOMBRE_PRODUCTO"));

        List<DatabaseMapping> explicit = List.of(
                new DatabaseMapping(null, "FECHA_INGESTA", "TIMESTAMP", null, "")
        );

        List<DatabaseMapping> result = autoMapper.resolve(List.of(), "T_VENTAS", null, explicit);

        assertThat(result).hasSize(1);
        assertThat(result.get(0).isAutoGenerated()).isTrue();
    }

    @Test
    @DisplayName("Excel columns without DB match should be ignored")
    void unmatchedExcelColumnsShouldBeIgnored() {
        when(tableMetadataPort.getColumnNames("T_VENTAS", null))
                .thenReturn(List.of("PRECIO"));

        List<String> excelHeaders = List.of("Precio", "Columna extra", "Otra columna");

        List<DatabaseMapping> result = autoMapper.resolve(excelHeaders, "T_VENTAS", null, List.of());

        assertThat(result).hasSize(1);
        assertThat(result.get(0).dbColumn()).isEqualTo("PRECIO");
    }
}
